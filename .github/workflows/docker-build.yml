name: Build and Push

on:
  workflow_dispatch: # Permite ejecuciÃ³n manual desde GitHub Actions

permissions:
  contents: read
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  get-next-version:
    runs-on: ubuntu-latest
    permissions:
      packages: read
    outputs:
      version: ${{ steps.increment.outputs.version }}
    steps:
      - name: Get latest version and increment
        id: increment
        run: |
          set -euo pipefail
          
          # FunciÃ³n para logging seguro
          log_info() { echo "â„¹ï¸  $1"; }
          log_warn() { echo "âš ï¸  $1"; }
          log_error() { echo "âŒ $1"; }
          log_success() { echo "âœ… $1"; }

          # Normalizar nombres a minÃºsculas
          OWNER=$(echo "${{ github.repository_owner }}" | tr '[:upper:]' '[:lower:]')
          REPO=$(echo "${{ github.event.repository.name }}" | tr '[:upper:]' '[:lower:]')
          API_URL="https://api.github.com/users/${OWNER}/packages/container/${REPO}/versions?per_page=100"

          log_info "Buscando versiones existentes en GitHub Packages..."
          log_info "Owner: ${OWNER}, Repo: ${REPO}"

          # Intentar obtener versiones con manejo de errores
          HTTP_CODE=0
          RESPONSE=""
          
          RESPONSE=$(curl -w "\n%{http_code}" -fsSL \
            -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
            -H "Accept: application/vnd.github+json" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            "$API_URL" 2>/dev/null || echo -e "\n000")
          
          # Separar respuesta y cÃ³digo HTTP
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          RESPONSE=$(echo "$RESPONSE" | sed '$d')

          log_info "HTTP Status Code: ${HTTP_CODE}"

          # Validar respuesta de la API
          if [ "$HTTP_CODE" = "404" ]; then
            log_warn "Package no existe aÃºn. Iniciando en versiÃ³n 1.0"
            NEW_VERSION="1.0"
          elif [ "$HTTP_CODE" = "000" ] || [ -z "$HTTP_CODE" ] || [ "$HTTP_CODE" != "200" ]; then
            log_warn "Error al consultar API (cÃ³digo: ${HTTP_CODE}). Iniciando en versiÃ³n 1.0"
            NEW_VERSION="1.0"
          else
            log_success "Respuesta exitosa de la API"
            
            # Validar que la respuesta sea JSON vÃ¡lido
            if ! echo "$RESPONSE" | jq empty 2>/dev/null; then
              log_warn "Respuesta no es JSON vÃ¡lido. Iniciando en versiÃ³n 1.0"
              NEW_VERSION="1.0"
            else
              # Extraer tags con manejo de errores
              TAGS=$(echo "$RESPONSE" | jq -r '.[].metadata.container.tags[]? // empty' 2>/dev/null | grep -v '^$' || echo "")
              
              if [ -z "$TAGS" ]; then
                log_warn "No se encontraron tags. Iniciando en versiÃ³n 1.0"
                NEW_VERSION="1.0"
              else
                log_info "Tags encontrados:"
                echo "$TAGS" | head -n 5 | sed 's/^/  - /'
                [ $(echo "$TAGS" | wc -l) -gt 5 ] && echo "  ... (y mÃ¡s)"
                
                # Filtrar solo tags con formato numÃ©rico X.Y
                NUMERIC_TAGS=$(echo "$TAGS" | grep -E '^[0-9]+\.[0-9]+$' || echo "")
                
                if [ -z "$NUMERIC_TAGS" ]; then
                  log_warn "No se encontraron tags con formato numÃ©rico (X.Y). Iniciando en versiÃ³n 1.0"
                  NEW_VERSION="1.0"
                else
                  # Encontrar la versiÃ³n mÃ¡s alta
                  LATEST_VERSION=$(echo "$NUMERIC_TAGS" | sort -t. -k1,1n -k2,2n | tail -n1)
                  
                  if [ -z "$LATEST_VERSION" ]; then
                    log_warn "Error al procesar versiÃ³n mÃ¡s alta. Iniciando en versiÃ³n 1.0"
                    NEW_VERSION="1.0"
                  else
                    log_info "Ãšltima versiÃ³n numÃ©rica encontrada: ${LATEST_VERSION}"
                    
                    # Incrementar versiÃ³n de forma segura
                    MAJOR=$(echo "$LATEST_VERSION" | cut -d. -f1)
                    MINOR=$(echo "$LATEST_VERSION" | cut -d. -f2)
                    
                    # Validar que MAJOR y MINOR sean nÃºmeros
                    if ! [[ "$MAJOR" =~ ^[0-9]+$ ]] || ! [[ "$MINOR" =~ ^[0-9]+$ ]]; then
                      log_warn "VersiÃ³n con formato invÃ¡lido. Iniciando en versiÃ³n 1.0"
                      NEW_VERSION="1.0"
                    else
                      NEW_MINOR=$((MINOR + 1))
                      NEW_VERSION="${MAJOR}.${NEW_MINOR}"
                      log_info "Incrementando versiÃ³n: ${LATEST_VERSION} â†’ ${NEW_VERSION}"
                    fi
                  fi
                fi
              fi
            fi
          fi

          log_success "Nueva versiÃ³n a utilizar: ${NEW_VERSION}"
          echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT

  build-and-push:
    needs: get-next-version
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=${{ needs.get-next-version.outputs.version }}
            type=raw,value=latest
          flavor: |
            latest=auto

      - name: Build and push Docker image (AMD64 only)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Build Summary
        if: success()
        run: |
          IMAGE_FULL=$(echo "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]')
          
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "ğŸš€ Build completado exitosamente!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ“‹ InformaciÃ³n del Build:"
          echo "  ğŸ·ï¸  VersiÃ³n: ${{ needs.get-next-version.outputs.version }}"
          echo "  ğŸ—ï¸  Plataforma: linux/amd64"
          echo "  ğŸ“¦ Repositorio: ${{ github.repository }}"
          echo ""
          echo "ğŸ“¦ ImÃ¡genes publicadas:"
          echo "  â€¢ ${IMAGE_FULL}:${{ needs.get-next-version.outputs.version }}"
          echo "  â€¢ ${IMAGE_FULL}:latest"
          echo ""
          echo "ğŸ³ Comando para usar la imagen:"
          echo "  docker pull ${IMAGE_FULL}:${{ needs.get-next-version.outputs.version }}"
          echo ""
          echo "âœ… Â¡Imagen lista para usar!"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

      - name: Build Summary (On Failure)
        if: failure()
        run: |
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo "âŒ El build fallÃ³"
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
          echo ""
          echo "ğŸ” Revisa los logs anteriores para mÃ¡s detalles"
          echo "ğŸ’¡ Verifica que:"
          echo "  â€¢ El Dockerfile existe y es vÃ¡lido"
          echo "  â€¢ Los permisos de GitHub Packages estÃ¡n correctos"
          echo "  â€¢ El token GITHUB_TOKEN tiene permisos de escritura"
          echo ""
          echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"